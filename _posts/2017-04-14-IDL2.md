---
layout: post
title: IDL学习记录(二)
date: 2017-04-14
excerpt: 最近开始学习使用IDL了，记录一些这几个月的学习感悟，这是下篇。
tag: 
- IDL
- 科研
- 编程
---

接着[上篇](http://windfire007.com/IDL1/)来写。

大部分数据一般都是以时间作为自变量，在画图的时候，无法直接使用日期来作为变量，例如201511301245与201512010515这两个时间点的间隔就不好算出。这时候就需要利用函数`julday`，其标准使用方法为`julday(month,day,year,hour,minute,second)`，前三项日期为必须，时间项则非必须。该函数返回一个数值，大概就是从某年开始算起的第几天，完全将时间转换为了线性关系。注意每天的整数值是中午12点，如果不含时间，那么返回值是一个整数，反之则是小数。由于有误差的原因，`julday(3,17,2015)` 并不等于`julday(3,17,2015,12)`，这点一定要额外注意。例如我们有一组带时间的数据，要取一段日期，而日期的范围往往不带时间，这时直接用等于去找范围是找不到的。相对的有一个过程`caldat`为该函数的相反算法，具体可以参见帮助。

对于已经读取的数据，有时候要将数据进行分组，例如一个长期数据要按照年代分类存储，假设经过一些处理后年份变量为`year`，其余变量为`data`，则对应的完整数据是`[year[i],data[i]]`。

```
temp=year[sort(year)]  ;如果数据并非是按时间排序，需要先排序
index=uniq(temp)  ;对排序后的时间找出分界点
date=temp[index]  ;得到去重复的排序后时间
index=[-1,index]
temp=data[sort(year)]  ;将数据按照年份排序
for i=2,n_elements(index) do begin
	var=temp[index[i-2]+1:index[i-1]]
	save,var,file=path+strcompress(string(date[i-2]),/remove_all)+'.sav'		
	;存储该年份的数据到指定路径下“年份.sav”文件
endfor
```

这是我在需要算背景值的时候想到的方法，某时刻的背景值一般取前几天该时刻数据的中值。因为实在不想用for循环硬数，并且考虑到数据并不一定是完整的，所以就想着利用系统默认函数来写个算法。对于日期来说都是用`julday`转换过的，这时候取1的余数，得到只有小数的日期。然后就要把数据对每一个时刻进行分类，并求出中值来。得到一天内各时刻的中值后，接下来画图的时候就要考虑如何让这个数据循环起来。数据很简单的利用`rebin`函数重复数组，然后利用`reform`函数转化为一维数组。日期的话要额外利用`indgen(1,n)`来生成日期差。

在需要处理的数据中，还有一种是将一天各个时刻的数据写在了同一行中，例如一行有25个数，其中第一个为日期，2-25为0时-23时的各时刻数据。这时候为了画图方便把日期也转换为这种二维数组，直接对二维数组进行画图，当然利用`reform`转化为一维数组再画图也可以，不过没必要。

```
temp=[0:23]  ;创建时间数组
hour=julday(1,1,1,temp) mod 1  ;把单纯的时刻转化为线性
hour[0:11]--
;因为julday函数是由12点起计算，所以需要调整成从0点开始
time=rebin(transpose(date),24,n_elements(date))+rebin(hour,24,n_elements(date))
;扩展日期数组并加上时间，这里的date已转换为线性日期
```

前面也说了，有些数据是经常会有缺失的，而这些缺失在画图时是需要空出来的，必须要标记为`!values.f_nan`。所以也需要找出到底哪里缺了数据，由于我还不会用代码直接在文本中插入数据，所以方法就是利用代码找出缺失的位置，然后手动补上。这里说的数据日期格式是`201502182130`，每15分钟一个数据。首先提取出日期，然后去重，先确认有没有整天缺失的，同理对小时也这样处理。接下来就是要保证每小时有4个点，思路很简单，小时数据去重后序号应该是个公差为4的等差数列，那么直接和一个公差为4的等差数列相减，得到的差再去重，这时候的序号则应该在缺失数据附近。

然后就是最重要的画图部分，一切的数据处理都是为了画图，使用过程`plot`，不过也有函数`plot`但是我并没用过。首先是画图时的参数设置，`!p.multi`是多图参数，在一张图上话多幅图时需要，变量值是1*3的数组，不过这个变量很迷，我也一直没弄清楚，没调好的话可能会让图上只有一张图，背景参数也能使其无效，得到黑背景黑图片。一般用的时候要多试试，初步来说前两个参数我都写了0，第三个参数为图片个数，大概没啥问题。

字体大小调成0.01可以不显示，一般画多幅图时，中间几个图的x轴都是没有标签的。最下面一张图上显示x轴标签，这里自变量一般都是日期，而日期在处理时都换成了线性的数字，需要再转化为标准的日期，这时候就要利用函数来设置时间的格式：`label_date(date_format='%n/%d')`。具体格式参数详见帮助，不过这函数的返回值貌似没有卵用啊，一般我都是让它返回到临时变量。之后在x轴参数里设置`!x.tickformat='label_date'`就可以了。和`julday`一样，这里默认时间标签的刻度在每天的12点，这个要注意。

画多图时，每个图的位置由参数`!p.position`确定，这个参量是一个1*4的数组，分别是图片左下角和右上角的坐标，坐标是归一化的，即范围是[0,1]。坐标原点在整个图的左下角啊，我第一次画图时下意识的以为远点在左上角了。在图上添加文字标签利用过程`xyouts`，这个坐标参量应该指的是文字左下角的坐标，坐标大小就是像素位置，并非归一化的。在使用`xyouts`时需要加上关键词`/device`。

在同一个坐标下再画图可以利用过程`oplot`，默认的是使用上一个图的坐标轴进行画图。当然还有另一种方法就是在相同位置直接用`plot`画一个没有坐标轴的图，这种好处是第二个图和第一个图不共用坐标轴。例如需要画在同一个坐标里的数据，其本身数据范围差距很大，这时就不能用`oplot`了。一般这种图左右y轴的刻度是不一样的，所以在画第一个图时隐藏右侧y轴，画第二个图时隐藏所有坐标轴，再利用过程`axis`补上一个坐标轴。在我单独画坐标轴时，如果使用坐标轴扩展范围的话，数据和坐标刻度就会有一个微小偏差，原因也不太清楚，我一般默认的是`!y.style=3`，但在画坐标轴时关键字要改为1。

​差不多就先写这么多，写代码这种东西，问题都是遇到了才有啊，接下来遇到了问题再写吧。不过接下来的想法是学习python，还有一年时间可以好好利用一下。