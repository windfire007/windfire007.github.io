---
layout: post
title: IDL学习记录(一)
date: 2017-04-13
excerpt: 最近开始学习使用IDL了，记录一些这几个月的学习感悟，这是上篇。
tag: 
- IDL
- 科研
- 编程
---

​	博客好久没写了，总觉得该写点什么。之前一直在学习idl，也有挺多感想的理解的，所以决定写一篇关于idl的博客，以备有些东西日后被遗忘。

​	基础知识的学习看的是[《IDL程序设计：数据可视化与ENVI二次开发》](https://item.jd.com/11103120.html)这本书.idl最主要的应用方向是遥感、GIS、地球物理等专业，节选书上对idl的介绍：

> ​	交互式数据语言——IDL（Interactive Data Language）是美国ExelisVis公司的产品，它是进行应用程序开发、科学数据分析与可视化表达的理想工具。

​	最初知道idl是因为某课的作业需要画磁场的图，老师当时说了句“你们交作业用什么画图呢？idl么？最次也要用matlab啊”。这句话的意思很简单，那就是在本专业的范围内，idl的画图效果远好于matlab，所以就有了想要学习idl的打算。

​	不过去年因为在mac上安装失败了，也就没再用了。今年来单位这边后，在win上装了idl，于是回去又想了想办法在mac上终于安装成功了。idl的软件一般是作为envi的附属品，当然也可以单独安装。作为收费软件，最新的版本网上似乎并没有破解，不过也不要去找太旧的版本，建议idl至少8.0以上。

​	win下的安装破解什么的我就不说了，mac在最新的mac os下装不了旧版的idl，新版又没人破解，所以也花费了一段时间去想怎么解决。解决步骤分为两个，第一步是在这个博客上找到的，[链接](http://blog.sciencenet.cn/blog-568426-920163.html)。发生原因是os x 10.10以后，x11的路径从usr/该到了opt/下，解决办法也就是在usr/下创建一个x11的软连接：

```bash
sudo mkdir /usr/X11/
sudo ln -s /opt/X11/* /usr/X11/
```

​	第二步找了很久终于在一个论坛里找到了结果，也是最根本的原因，[链接](http://compgroups.net/comp.lang.idl-pvwave/idl-on-mac-funning-yosemite/3001991)。试了试上面所说的方法，其中有一个是可行的，那就是删除idl程序下的`libz.1.dylib`，具体路径已经忘记了，在软件包里搜一下吧，印象中是个快捷方式。于是乎终于能在mac的新系统上用idl了。

​	首先说说idl使用过程的总体感觉，最重要的是要善于使用帮助，在控制台直接输入`?`就会自动跳转到帮助里，大部分的问题在帮助里都有说明。注意这里的问号当然是英文的问号，记得切换输入法。说到中文，idl的文本默认编码是utf-8，这也导致了在win下看别人的代码中文备注是乱码，不过我也一般不写备注。其次是编程效率问题，少用循环，能用默认函数处理就不要使用循环硬数数，这点是从一开始学习C语言时老师就强调过的，循环起来太慢了，严重影响时间效率。对于空间效率的问题，我喜欢全程用同一个边龙`temp`，用完即抛弃的那种，虽然说这个年代空间效率已经不重要了。

​	idl的模块分为两大类，过程（Procedure）和函数（Function），要说区别的话，我个人理解就是函数会给一个返回值，而过程则没有。很多模块都同时有过程和函数，功能也大体相似，不过一般来说我更喜欢用过程。这两个使用方法也不一样，例如：

```idl
procedure,a,b,keyword=c
b=fuction(a,keyword=c)
;a为变量，b为所得结果，c为关键词
```

​	接下来以我目前写的几个代码为例子，想到哪说哪吧。最开始的时候遇到了一个很基础的问题，那就是变量越界了。由于idl不像c那样需要先声明变量，直接拿来用就可以的，所以很有可能这个变量的类型与自己所期待的不一样，有些时候还是要初始化变量来设置变量类型。

​	然后就是读取数据的问题，一开始我用的是过程`openr`与`read`，由于read一次只能读取一行，所以就是跑循环`while(~eof(lun))`（`lun`为`openr`读取出来与文件关联的设备和），一行一行的读取文本数据，然后手动加到数组中。之前也说了尽量不要用循环，跑循环速度及其慢，第一次读的数据就跑了2个小时，还经常出bug要重读。于是乎为了节省时间效率，就找到了一个函数`read_ascii`，此函数默认返回一个结构体，结构体只包含一个成员，是一个读取了全部数据的n*m数组。用函数的速度远大于循环，速度十分之快。还可以详细设置读取样式，利用关键词`template`来设置，其中`template`的值由函数`ascii_template`返回。当使用`ascii_template`函数时，会弹出图形界面直接操作，可设置很多的读取格式，选定之后返回一个结构体。不过这个`ascii_template`的图形界面还是不够细致，那么我们可以参考函数所返回来的结构体格式，直接自己手动创建一个同样的结构体，这样其中的参数就可以自由修改了。

​	在测量数组个数的时候，习惯性的用`size`函数，但是该函数返回的是个数组，并非是一个标量。这时候就要记住有个函数`n_elements`是直接返回数组个数的，可以直接用在for循环等过程、函数里。傻得我一开始都没注意到这个函数，还用`l=size(a)&n=l[1]`，明明书上都提过这个函数。

​	在画图过程中，由于数据的缺失，我们需要将确实的数据写上“缺失”，而不能直接空下来，直接空下来的话，缺失的部分会用直线直接连起来，这明显会影响数据的变化趋势。所以这时候就需要一个特殊的数来占位，这个占位的数在系统变量`!values`下，有单精度型小数`f_nan`和双精度型小数`d_nan`。例如数据中的坏值或缺失值用99999来表示，可以利用返回数组中特定值序号的函数`where`来实现替换：`date[where(date eq 99999)]=!values.f_nan`。

​	当数据量大的时候读取时间往往会花费很多时间，所以往往将读取数据作为一个单独的步骤，先读取文本数据存到数组等变量里，然后将这些变量存储成二进制文件，方便之后的调用。这里的二进制文件格式为`.sav`，可以由`save`过程生产，读取由`restore`过程恢复数组，由于是专用的二进制文件，所以再次读取数组是十分的快。再给文件命名的时候，可能要将日期编号之类的保存到文件名中，当这些值不是字符串的时候，就需要转换为字符串了。但是把数字转换为字符串会在前面带很多空格，这是就需要用`strcompress`函数来去除空格，不过这应还是会剩下一个空格，再加上关键词`/remove_all`去除所有的空格。
